---
phase: 14-ci-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/__tests__/harness/local-runner.ts
  - .github/workflows/pr-validation.yml
  - .github/workflows/release-validation.yml
autonomous: true

must_haves:
  truths:
    - "PR workflow runs validation on 5 core tier configs in parallel"
    - "Release workflow runs validation on all 14 configs in parallel"
    - "CI failure blocks merge with clear error output"
    - "Individual config can be run via npm run test:e2e -- config-name"
  artifacts:
    - path: ".github/workflows/pr-validation.yml"
      provides: "PR validation workflow with matrix strategy"
      contains: "matrix:"
    - path: ".github/workflows/release-validation.yml"
      provides: "Release validation workflow with full matrix"
      contains: "matrix:"
    - path: "src/__tests__/harness/local-runner.ts"
      provides: "Single config execution support"
      contains: "getConfigByName"
  key_links:
    - from: ".github/workflows/pr-validation.yml"
      to: "npm run test:e2e"
      via: "npm script invocation with config argument"
      pattern: "npm run test:e2e --"
    - from: ".github/workflows/release-validation.yml"
      to: "npm run test:e2e"
      via: "npm script invocation with config argument"
      pattern: "npm run test:e2e --"
    - from: "src/__tests__/harness/local-runner.ts"
      to: "src/__tests__/harness/fixtures/matrix.ts"
      via: "getConfigByName import"
      pattern: "getConfigByName"
---

<objective>
Create GitHub Actions CI workflows that validate generated project configurations on PRs and releases.

Purpose: Ensure all generated project configurations are validated before code is merged (core tier on PRs) and before releases ship (full 14-config matrix). This catches template regressions automatically.

Output:
- PR workflow that runs 5 core configs in parallel matrix (~2-3 min)
- Release workflow that runs all 14 configs in parallel matrix (~3-5 min)
- Updated local-runner that accepts individual config names for CI matrix execution
</objective>

<execution_context>
@/Users/alwick/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alwick/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-ci-integration/14-RESEARCH.md
@src/__tests__/harness/local-runner.ts
@src/__tests__/harness/fixtures/matrix.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update local-runner to accept single config names</name>
  <files>src/__tests__/harness/local-runner.ts</files>
  <action>
Modify local-runner.ts to accept either a tier name OR a specific config name:

1. Import `getConfigByName` from fixtures (already exported in matrix.ts)

2. Update CLI argument parsing logic:
   - Keep existing tier detection (smoke, core, full)
   - Add detection for config names (check if arg matches a config in TEST_MATRIX)
   - If arg is a valid config name, run single-config mode
   - If arg is a valid tier, run tier mode (existing behavior)
   - If arg is invalid, show error with both valid tiers AND config names

3. Add single-config execution:
   - Create `runSingleConfig(configName: string)` function
   - Use getConfigByName(configName) to get the config
   - Run validateGeneratedProject for just that one config
   - Display result and exit with appropriate code

4. Keep existing runValidationSuite unchanged for tier execution

The result should work as:
- `npm run test:e2e` -> runs core tier (default, unchanged)
- `npm run test:e2e smoke` -> runs smoke tier (unchanged)
- `npm run test:e2e web-api-cognito` -> runs single config (NEW)
  </action>
  <verify>
1. `npm run build` compiles without errors
2. `npm run test:e2e -- --help` or invalid arg shows valid options including config names
3. TypeScript types are correct (no any types, proper imports)
  </verify>
  <done>
- local-runner accepts both tier names AND config names
- Invalid argument shows helpful error with valid options
- Single config execution exits 0 on pass, 1 on fail
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PR validation workflow</name>
  <files>.github/workflows/pr-validation.yml</files>
  <action>
Create `.github/workflows/pr-validation.yml` with:

1. Trigger: `on: pull_request` to main branch only

2. Job `validate`:
   - runs-on: ubuntu-latest
   - timeout-minutes: 10
   - strategy.fail-fast: false (run all configs even if one fails)
   - matrix.config: 5 core tier configs:
     - web-api-cognito (smoke)
     - web-cognito (core)
     - mobile-auth0 (core)
     - api-cognito (core)
     - full-auth0 (core)

3. Steps:
   - actions/checkout@v4
   - actions/setup-node@v6 with node-version: 22, cache: 'npm'
   - npm ci (install dependencies)
   - npm run test:e2e -- ${{ matrix.config }} with env CI: true
   - Upload artifacts on failure (if: failure()) with actions/upload-artifact@v4

4. Job `ci-complete`:
   - needs: validate
   - Simple echo step confirming all validations passed
   - This job is what branch protection should require

Use the exact workflow structure from 14-RESEARCH.md "PR Validation Workflow" example.
  </action>
  <verify>
1. File exists at .github/workflows/pr-validation.yml
2. YAML is valid (no syntax errors)
3. Matrix includes exactly 5 configs
4. ci-complete job depends on validate job
  </verify>
  <done>
- PR workflow file created with matrix strategy
- Triggers on pull_request to main
- 5 core configs run in parallel
- ci-complete job exists for branch protection
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Release validation workflow</name>
  <files>.github/workflows/release-validation.yml</files>
  <action>
Create `.github/workflows/release-validation.yml` with:

1. Trigger: `on: release: types: [published]` (NOT drafts, only published)

2. Job `validate`:
   - runs-on: ubuntu-latest
   - timeout-minutes: 15 (longer for 14 configs)
   - strategy.fail-fast: false
   - matrix.config: all 14 configs:
     - web-api-cognito
     - web-cognito
     - mobile-auth0
     - api-cognito
     - full-auth0
     - web-auth0
     - mobile-cognito
     - api-auth0
     - web-mobile-cognito
     - web-mobile-auth0
     - web-api-auth0
     - mobile-api-cognito
     - mobile-api-auth0
     - full-cognito

3. Steps: Same as PR workflow (checkout, setup-node, npm ci, test:e2e, upload on failure)

4. Job `release-complete`:
   - needs: validate
   - Echo confirming all 14 configurations validated

Use the exact workflow structure from 14-RESEARCH.md "Release Validation Workflow" example.
  </action>
  <verify>
1. File exists at .github/workflows/release-validation.yml
2. YAML is valid (no syntax errors)
3. Matrix includes exactly 14 configs
4. Triggers on release published only
  </verify>
  <done>
- Release workflow file created with full matrix strategy
- Triggers only on published releases (not drafts)
- All 14 configs run in parallel
- release-complete job exists for verification
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `npm test` passes (existing tests)
3. Workflow YAML files are syntactically valid
4. local-runner accepts config name argument
5. Both workflow files have correct matrix configs
</verification>

<success_criteria>
- [ ] local-runner.ts accepts tier OR config name arguments
- [ ] .github/workflows/pr-validation.yml exists with 5-config matrix
- [ ] .github/workflows/release-validation.yml exists with 14-config matrix
- [ ] Both workflows use actions/checkout@v4, actions/setup-node@v6
- [ ] Both workflows have fail-fast: false
- [ ] Both workflows have ci-complete/release-complete jobs
- [ ] Both workflows upload artifacts on failure
- [ ] npm run build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-ci-integration/14-01-SUMMARY.md`
</output>
