---
phase: 19-idempotent-setup-improvements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aws/organizations.ts
  - src/commands/setup-aws-envs.ts
autonomous: true

must_haves:
  truths:
    - "User with existing accounts in AWS is not re-prompted for their email addresses"
    - "setup-aws-envs only prompts for emails of accounts that need to be created"
    - "Partial re-runs (after failures) resume from last successful step without re-prompting completed information"
    - "All three accounts already exist in AWS -> zero email prompts shown"
    - "One account exists, two missing -> only two email prompts shown"
  artifacts:
    - path: "src/aws/organizations.ts"
      provides: "listOrganizationAccounts function with pagination"
      exports: ["listOrganizationAccounts"]
      contains: "ListAccountsCommand"
    - path: "src/commands/setup-aws-envs.ts"
      provides: "Pre-flight account discovery and conditional email prompting"
      contains: "listOrganizationAccounts"
  key_links:
    - from: "src/commands/setup-aws-envs.ts"
      to: "src/aws/organizations.ts"
      via: "import listOrganizationAccounts"
      pattern: "import.*listOrganizationAccounts.*from.*organizations"
    - from: "src/commands/setup-aws-envs.ts"
      to: "AWS Organizations API"
      via: "listOrganizationAccounts call before collectEmails"
      pattern: "listOrganizationAccounts.*client"
    - from: "src/commands/setup-aws-envs.ts"
      to: "prompts library"
      via: "type function returning null to skip prompts"
      pattern: "type.*=>.*null"
---

<objective>
Make setup-aws-envs fully idempotent by discovering existing AWS accounts before prompting and only collecting emails for accounts that need creation.

Purpose: When users re-run setup-aws-envs (after partial failure or to add missing resources), they should not be asked for email addresses of accounts that already exist in AWS. This satisfies requirements IDEM-01, IDEM-02, and IDEM-03.

Output: Modified organizations.ts with listOrganizationAccounts function, and setup-aws-envs.ts with pre-flight discovery, conditional prompting, and merged account handling.
</objective>

<execution_context>
@/Users/alwick/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alwick/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-idempotent-setup-improvements/19-RESEARCH.md
@src/aws/organizations.ts
@src/commands/setup-aws-envs.ts
@src/utils/project-context.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add listOrganizationAccounts to organizations.ts</name>
  <files>src/aws/organizations.ts</files>
  <action>
Add a new exported function `listOrganizationAccounts` to `src/aws/organizations.ts` that:

1. Import `ListAccountsCommand` and `Account` type from `@aws-sdk/client-organizations` (add to existing import statement at top of file).

2. Create function with signature:
```typescript
export async function listOrganizationAccounts(
  client: OrganizationsClient
): Promise<Account[]>
```

3. Implementation must handle pagination using do-while loop with NextToken:
   - Call `ListAccountsCommand` with `{ NextToken: nextToken }`
   - Accumulate `response.Accounts` into array (guard with `if (response.Accounts)`)
   - Set `nextToken = response.NextToken`
   - Continue while nextToken is defined
   - Return accumulated accounts array

4. Add JSDoc comment explaining it lists all accounts in the organization with automatic pagination handling.

Place the function AFTER the existing `checkExistingOrganization` function and BEFORE the `createAccount` function (logical grouping: query operations together).

Do NOT modify any existing functions. Only add the new function and update the import.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Grep for `listOrganizationAccounts` in organizations.ts to confirm export exists. Grep for `ListAccountsCommand` in the import to confirm the import was added.
  </verify>
  <done>
`listOrganizationAccounts` is exported from organizations.ts, accepts OrganizationsClient, returns Promise of Account[], handles pagination with NextToken loop, and compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate pre-flight discovery and conditional prompting into setup-aws-envs</name>
  <files>src/commands/setup-aws-envs.ts</files>
  <action>
Modify `src/commands/setup-aws-envs.ts` to query AWS for existing accounts before prompting for emails, then only prompt for environments that need account creation. This involves four changes:

**Change 1: Add import**
Add `listOrganizationAccounts` to the import from `../aws/organizations.js` (existing import statement, just add to the destructured imports).

**Change 2: Modify `collectEmails` function signature and implementation**

Change the function signature to accept which environments need creation:
```typescript
async function collectEmails(
  projectName: string,
  environmentsToCreate: readonly string[]
): Promise<Record<string, string>>
```

Return type changes from `EnvironmentEmails` to `Record<string, string>` (only contains emails for environments that need creation). Remove the `EnvironmentEmails` interface since it's no longer needed.

Replace the three sequential `prompts()` calls with a single `prompts()` call using an array of prompt objects where each prompt's `type` is a function that returns `'text'` if the environment needs creation, or `null` to skip:

```typescript
const emailPrompts = [
  {
    type: () => (environmentsToCreate.includes('dev') ? 'text' as const : null),
    name: 'dev',
    message: 'Dev account root email:',
    validate: validateEmail,
  },
  {
    type: (_prev: unknown, values: Record<string, string>) =>
      environmentsToCreate.includes('stage') ? 'text' as const : null,
    name: 'stage',
    message: 'Stage account root email:',
    validate: (v: string, _prev: unknown, values: Record<string, string>) =>
      validateUniqueEmail(v, [values?.dev].filter(Boolean)),
  },
  {
    type: (_prev: unknown, values: Record<string, string>) =>
      environmentsToCreate.includes('prod') ? 'text' as const : null,
    name: 'prod',
    message: 'Prod account root email:',
    validate: (v: string, _prev: unknown, values: Record<string, string>) =>
      validateUniqueEmail(v, [values?.dev, values?.stage].filter(Boolean)),
  },
];
```

NOTE on prompts library: The `validate` function in prompts receives `(value, values)` as arguments where `values` is the accumulated answers object. Check the actual prompts library API - the validate signature for prompts is `validate: (value) => boolean | string | Promise<boolean | string>`. The previous values are NOT passed to validate. Instead, since we're using a single `prompts()` call with an array, we can reference the collected responses object. Look at the prompts library docs carefully. The `type` function receives `(prev, values, prompt)`. The `validate` function only receives `(value)`.

Since validate only gets the value, we need to track collected emails differently. Use a closure approach:
```typescript
const collectedEmails: string[] = [];

const emailPrompts = [
  {
    type: () => (environmentsToCreate.includes('dev') ? 'text' as const : null),
    name: 'dev',
    message: 'Dev account root email:',
    validate: validateEmail,
  },
  {
    type: () => environmentsToCreate.includes('stage') ? 'text' as const : null,
    name: 'stage',
    message: 'Stage account root email:',
    validate: (v: string) => validateUniqueEmail(v, collectedEmails),
  },
  {
    type: () => environmentsToCreate.includes('prod') ? 'text' as const : null,
    name: 'prod',
    message: 'Prod account root email:',
    validate: (v: string) => validateUniqueEmail(v, collectedEmails),
  },
];
```

Actually, the `prompts` library with array mode accumulates values in the response object, but validation functions only get the current value. The simplest correct approach: keep the three sequential `prompts()` calls but wrap each in a conditional check:

```typescript
async function collectEmails(
  projectName: string,
  environmentsToCreate: readonly string[]
): Promise<Record<string, string>> {
  // ... header messages ...

  if (environmentsToCreate.length < ENVIRONMENTS.length) {
    console.log(pc.dim('Note: Only collecting emails for accounts that need creation.'));
    console.log('');
  }

  // ... existing email/tip messages ...

  const onCancel = (): void => {
    console.log(`\n${pc.red('x')} Setup cancelled`);
    process.exit(1);
  };

  const emails: Record<string, string> = {};
  const collectedEmails: string[] = [];

  if (environmentsToCreate.includes('dev')) {
    const response = await prompts(
      { type: 'text', name: 'dev', message: 'Dev account root email:', validate: validateEmail },
      { onCancel }
    );
    if (!response.dev) { console.log(pc.red('Error:') + ' Dev email is required.'); process.exit(1); }
    emails.dev = response.dev;
    collectedEmails.push(response.dev);
  }

  if (environmentsToCreate.includes('stage')) {
    const response = await prompts(
      {
        type: 'text', name: 'stage', message: 'Stage account root email:',
        validate: (v: string) => validateUniqueEmail(v, collectedEmails),
      },
      { onCancel }
    );
    if (!response.stage) { console.log(pc.red('Error:') + ' Stage email is required.'); process.exit(1); }
    emails.stage = response.stage;
    collectedEmails.push(response.stage);
  }

  if (environmentsToCreate.includes('prod')) {
    const response = await prompts(
      {
        type: 'text', name: 'prod', message: 'Prod account root email:',
        validate: (v: string) => validateUniqueEmail(v, collectedEmails),
      },
      { onCancel }
    );
    if (!response.prod) { console.log(pc.red('Error:') + ' Prod email is required.'); process.exit(1); }
    emails.prod = response.prod;
    collectedEmails.push(response.prod);
  }

  return emails;
}
```

This approach is safer - it preserves the existing sequential prompt pattern, just wraps each in a conditional. Easier to verify correctness.

**Change 3: Add pre-flight account discovery in `runSetupAwsEnvs`**

AFTER the Organization check/create block (around line 359, after `spinner.succeed` for org) and BEFORE the `collectEmails` call, insert account discovery logic:

```typescript
// Discover existing accounts from AWS (source of truth)
spinner.start('Checking for existing AWS accounts...');
const allOrgAccounts = await listOrganizationAccounts(client);

// Map accounts by environment using name pattern matching
const discoveredAccounts = new Map<string, string>();
for (const account of allOrgAccounts) {
  for (const env of ENVIRONMENTS) {
    const expectedName = `${config.projectName}-${env}`;
    if (account.Name === expectedName && account.Id) {
      discoveredAccounts.set(env, account.Id);
    }
  }
}

// Determine which environments still need account creation
const environmentsNeedingCreation = ENVIRONMENTS.filter(
  env => !discoveredAccounts.has(env)
);

// Report findings
for (const [env, accountId] of discoveredAccounts.entries()) {
  spinner.info(`Found existing ${env} account: ${accountId}`);
}

// Warn if config has accounts not found in AWS
for (const [env, accountId] of Object.entries(existingAccounts)) {
  if (!discoveredAccounts.has(env)) {
    console.log(pc.yellow('Warning:') + ` Account ${env} (${accountId}) in config but not found in AWS Organization`);
  }
}

spinner.stop();
```

IMPORTANT: This discovery block must happen INSIDE the try block, AFTER the Organizations client is created and org is checked, but BEFORE email collection. The flow is:
1. Create OrganizationsClient (existing)
2. Check/create organization (existing)
3. **NEW: Discover existing accounts from AWS**
4. **MOVED: Conditional email collection (only for missing envs)**
5. Account creation loop (existing, but now uses discoveredAccounts)

**Change 4: Move email collection inside try block and make conditional**

Move the `collectEmails` call from its current position (line 328, outside try block) to inside the try block, after the discovery block. Make it conditional:

```typescript
// Collect emails only for environments that need account creation
let emails: Record<string, string> = {};
if (environmentsNeedingCreation.length > 0) {
  // Must be outside spinner (prompts conflict with ora)
  spinner.stop();
  emails = await collectEmails(config.projectName, environmentsNeedingCreation);
  spinner.start('Continuing AWS setup...');
} else {
  spinner.stop();
  console.log('');
  console.log(pc.green('All environment accounts already exist in AWS.'));
  console.log(pc.dim('Skipping email collection, proceeding to deployment user setup...'));
  console.log('');
}
```

**Change 5: Update account creation loop to use discovered accounts**

Update the accounts initialization to start from discovered AWS accounts (not just config):

```typescript
// Start with accounts discovered from AWS (source of truth)
const accounts: Record<string, string> = { ...existingAccounts };
for (const [env, accountId] of discoveredAccounts.entries()) {
  accounts[env] = accountId;
}
```

And update the skip condition in the creation loop to check both config AND discovered:
```typescript
for (const env of ENVIRONMENTS) {
  // Skip if account already exists (in config OR discovered from AWS)
  if (accounts[env]) {
    spinner.succeed(`Using existing ${env} account: ${accounts[env]}`);
    continue;
  }
  // ... rest of creation logic uses emails[env] ...
}
```

Also update config with any newly discovered accounts that weren't in config before:
```typescript
// Update config with discovered accounts (sync config with AWS state)
if (discoveredAccounts.size > 0) {
  updateConfig(configPath, accounts);
}
```

**What NOT to do:**
- Do NOT change the Organization check/create logic
- Do NOT change the deployment user creation loop (it already skips existing)
- Do NOT change the access key creation loop (it already skips existing)
- Do NOT change error handling
- Do NOT add new dependencies
- Do NOT change the admin user/root detection flow
  </action>
  <verify>
1. Run `npx tsc --noEmit` - must pass with no type errors.
2. Run `npm run build` - must succeed.
3. Grep setup-aws-envs.ts for `listOrganizationAccounts` - must find import and usage.
4. Grep setup-aws-envs.ts for `environmentsNeedingCreation` - must find the filtering logic.
5. Grep setup-aws-envs.ts for `discoveredAccounts` - must find the Map creation and usage.
6. Verify `collectEmails` now accepts two parameters (projectName and environmentsToCreate).
7. Verify the `EnvironmentEmails` interface is removed (replaced by Record<string, string>).
  </verify>
  <done>
1. setup-aws-envs queries AWS Organizations for existing accounts BEFORE prompting for emails.
2. collectEmails only prompts for environments in the `environmentsNeedingCreation` array.
3. When all 3 accounts exist in AWS, zero email prompts are shown.
4. When 1 account exists, only 2 email prompts are shown.
5. Account creation loop uses merged state from AWS discovery + config.
6. Config is updated with discovered accounts to stay in sync with AWS.
7. Email uniqueness validation still works correctly using collectedEmails closure array with .filter(Boolean).
8. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `npx tsc --noEmit` passes - no type errors
2. `npm run build` succeeds - project compiles
3. `listOrganizationAccounts` exported from organizations.ts with pagination
4. setup-aws-envs.ts imports and calls `listOrganizationAccounts` after org check but before email collection
5. `collectEmails` accepts `environmentsToCreate` parameter and conditionally prompts
6. Account creation loop uses `discoveredAccounts` map merged with config accounts
7. When all accounts exist in AWS, no email prompts shown (environmentsNeedingCreation is empty)
8. Config updated with AWS-discovered accounts on each run
</verification>

<success_criteria>
- IDEM-01: setup-aws-envs skips email prompts for accounts that already exist in config (and AWS)
- IDEM-02: setup-aws-envs only prompts for emails of accounts that need to be created
- IDEM-03: Partial re-runs resume from last successful step without re-prompting completed information
- No regression: fresh runs with no existing accounts still prompt for all 3 emails
- No regression: deployment user and access key creation loops still skip existing resources
- TypeScript compiles, project builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/19-idempotent-setup-improvements/19-01-SUMMARY.md`
</output>
