---
phase: 04-cli-infrastructure-command-routing
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/utils/project-context.ts
  - src/commands/setup-aws-envs.ts
  - src/commands/initialize-github.ts
  - src/cli.ts
autonomous: true

must_haves:
  truths:
    - "User runs setup-aws-envs from inside project and command proceeds"
    - "User runs setup-aws-envs from outside project and gets clear error"
    - "User runs initialize-github dev from inside project and command proceeds"
    - "User runs initialize-github prod from outside project and gets clear error"
    - "Error message tells user to run from inside a project created with create-aws-project"
  artifacts:
    - path: "src/utils/project-context.ts"
      provides: "Project context detection utilities"
      exports: ["detectProjectContext", "requireProjectContext", "CONFIG_FILE", "ProjectContext"]
      min_lines: 40
    - path: "src/commands/setup-aws-envs.ts"
      provides: "AWS environments setup command"
      exports: ["runSetupAwsEnvs"]
      min_lines: 20
    - path: "src/commands/initialize-github.ts"
      provides: "GitHub initialization command"
      exports: ["runInitializeGitHub"]
      min_lines: 30
  key_links:
    - from: "src/commands/setup-aws-envs.ts"
      to: "src/utils/project-context.ts"
      via: "import requireProjectContext"
      pattern: "requireProjectContext"
    - from: "src/commands/initialize-github.ts"
      to: "src/utils/project-context.ts"
      via: "import requireProjectContext"
      pattern: "requireProjectContext"
    - from: "src/cli.ts"
      to: "src/commands/setup-aws-envs.ts"
      via: "import runSetupAwsEnvs"
      pattern: "runSetupAwsEnvs"
    - from: "src/cli.ts"
      to: "src/commands/initialize-github.ts"
      via: "import runInitializeGitHub"
      pattern: "runInitializeGitHub"
---

<objective>
Create project context detection and stub commands for setup-aws-envs and initialize-github

Purpose: Enable commands to detect when they're run from inside a valid project directory and provide clear error messages when not. Create the command stub files that will be fully implemented in Phases 6 and 7.

Output: project-context.ts utility, setup-aws-envs.ts command stub, initialize-github.ts command stub, updated cli.ts imports
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v1.3-ROADMAP.md
@.planning/phases/04-cli-infrastructure-command-routing/04-RESEARCH.md

# From Plan 01
@src/cli.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project-context.ts utility</name>
  <files>src/utils/project-context.ts</files>
  <action>
Create src/utils/project-context.ts with project context detection utilities:

```typescript
/**
 * Project context detection utilities
 *
 * Detects whether commands are run from inside a valid project directory
 * by searching upward for .aws-starter-config.json
 */

import { findUp } from 'find-up';
import { readFile } from 'node:fs/promises';
import { dirname } from 'node:path';
import pc from 'picocolors';

/**
 * Config file name that marks a project directory
 * This file is generated by the wizard and contains project settings
 */
export const CONFIG_FILE = '.aws-starter-config.json';

/**
 * Minimal project config structure for context detection
 * Full config defined in types.ts - this is subset needed for context
 */
export interface ProjectConfigMinimal {
  projectName: string;
  platforms: string[];
  awsRegion: string;
  configVersion?: string;
}

/**
 * Project context containing config path, project root, and parsed config
 */
export interface ProjectContext {
  configPath: string;
  projectRoot: string;
  config: ProjectConfigMinimal;
}

/**
 * Detects if running from inside a valid project directory
 * Searches upward from cwd for CONFIG_FILE
 *
 * @returns ProjectContext if found, null otherwise
 */
export async function detectProjectContext(): Promise<ProjectContext | null> {
  const configPath = await findUp(CONFIG_FILE);

  if (!configPath) {
    return null;
  }

  try {
    const content = await readFile(configPath, 'utf-8');
    const config = JSON.parse(content) as ProjectConfigMinimal;

    // Basic validation - config must have projectName
    if (!config.projectName) {
      return null;
    }

    return {
      configPath,
      projectRoot: dirname(configPath),
      config,
    };
  } catch {
    // Invalid JSON or read error - treat as no context
    return null;
  }
}

/**
 * Requires project context, exits with error if not found
 * Use this for commands that must run from inside a project
 *
 * @returns ProjectContext (never returns null, exits on failure)
 */
export async function requireProjectContext(): Promise<ProjectContext> {
  const context = await detectProjectContext();

  if (!context) {
    console.error(pc.red('Error:') + ' Not inside a project directory.');
    console.error('');
    console.error('This command must be run from inside a project created with:');
    console.error(`  ${pc.cyan('npx create-aws-project <project-name>')}`);
    console.error('');
    console.error(`Expected config file: ${pc.cyan(CONFIG_FILE)}`);
    process.exit(1);
  }

  return context;
}
```

Create the utils directory if it doesn't exist.

IMPORTANT: Use find-up (installed in Plan 01). The findUp function returns the full path to the config file if found, or undefined if not found. It searches from cwd upward.
  </action>
  <verify>
Run `npm run build` to verify TypeScript compilation succeeds.
Check that src/utils/project-context.ts exists and exports detectProjectContext, requireProjectContext, CONFIG_FILE, and ProjectContext.
  </verify>
  <done>
src/utils/project-context.ts created with:
- CONFIG_FILE constant exported
- ProjectContext interface exported
- detectProjectContext() async function exported
- requireProjectContext() async function exported (exits on failure)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create setup-aws-envs command stub</name>
  <files>src/commands/setup-aws-envs.ts</files>
  <action>
Create src/commands/setup-aws-envs.ts as a stub command that validates project context:

```typescript
/**
 * setup-aws-envs command
 *
 * Sets up AWS Organizations and environment accounts (dev, stage, prod)
 * Must be run from inside a project directory
 *
 * Full implementation in Phase 6
 */

import pc from 'picocolors';
import { requireProjectContext } from '../utils/project-context.js';

/**
 * Runs the setup-aws-envs command
 *
 * @param _args Command arguments (unused in stub)
 */
export async function runSetupAwsEnvs(_args: string[]): Promise<void> {
  // Validate we're in a project directory
  const context = await requireProjectContext();

  // Stub implementation - will be replaced in Phase 6
  console.log('');
  console.log(pc.cyan('setup-aws-envs') + ' command');
  console.log('');
  console.log(`Project: ${pc.bold(context.config.projectName)}`);
  console.log(`Region: ${context.config.awsRegion}`);
  console.log(`Config: ${context.configPath}`);
  console.log('');
  console.log(pc.yellow('This command will be implemented in Phase 6.'));
  console.log('');
  console.log('It will:');
  console.log('  1. Create AWS Organization (if not exists)');
  console.log('  2. Create environment accounts (dev, stage, prod)');
  console.log('  3. Store account IDs in project config');
}
```

This is a stub - it validates project context and shows what the command will do. Full implementation comes in Phase 6 (AWS-01 through AWS-05).
  </action>
  <verify>
Run `npm run build` to verify compilation.
  </verify>
  <done>
src/commands/setup-aws-envs.ts created with:
- runSetupAwsEnvs(args) exported
- Calls requireProjectContext() to validate project directory
- Shows stub message with project info
  </done>
</task>

<task type="auto">
  <name>Task 3: Create initialize-github command stub</name>
  <files>src/commands/initialize-github.ts</files>
  <action>
Create src/commands/initialize-github.ts as a stub command that validates project context and environment argument:

```typescript
/**
 * initialize-github command
 *
 * Configures GitHub Environment with AWS credentials for a single environment
 * Must be run from inside a project directory
 * Requires environment name as argument (dev, stage, prod)
 *
 * Full implementation in Phase 7
 */

import pc from 'picocolors';
import { requireProjectContext } from '../utils/project-context.js';

const VALID_ENVIRONMENTS = ['dev', 'stage', 'prod'] as const;
type Environment = typeof VALID_ENVIRONMENTS[number];

/**
 * Validates environment argument
 * @param env Environment name to validate
 * @returns true if valid, false otherwise
 */
function isValidEnvironment(env: string): env is Environment {
  return VALID_ENVIRONMENTS.includes(env as Environment);
}

/**
 * Runs the initialize-github command
 *
 * @param args Command arguments - expects environment name as first arg
 */
export async function runInitializeGitHub(args: string[]): Promise<void> {
  // Validate we're in a project directory
  const context = await requireProjectContext();

  // Validate environment argument
  const envArg = args[0];

  if (!envArg) {
    console.error(pc.red('Error:') + ' Environment name required.');
    console.error('');
    console.error('Usage:');
    console.error(`  ${pc.cyan('npx create-aws-project initialize-github <env>')}`);
    console.error('');
    console.error('Where <env> is one of: ' + VALID_ENVIRONMENTS.join(', '));
    console.error('');
    console.error('Example:');
    console.error(`  ${pc.cyan('npx create-aws-project initialize-github dev')}`);
    process.exit(1);
  }

  if (!isValidEnvironment(envArg)) {
    console.error(pc.red('Error:') + ` Invalid environment: ${pc.bold(envArg)}`);
    console.error('');
    console.error('Valid environments: ' + VALID_ENVIRONMENTS.join(', '));
    process.exit(1);
  }

  // Stub implementation - will be replaced in Phase 7
  console.log('');
  console.log(pc.cyan('initialize-github') + ` ${pc.bold(envArg)}`);
  console.log('');
  console.log(`Project: ${pc.bold(context.config.projectName)}`);
  console.log(`Environment: ${pc.bold(envArg)}`);
  console.log(`Config: ${context.configPath}`);
  console.log('');
  console.log(pc.yellow('This command will be implemented in Phase 7.'));
  console.log('');
  console.log('It will:');
  console.log(`  1. Create IAM deployment user for ${envArg} environment`);
  console.log(`  2. Configure GitHub Environment with AWS credentials`);
  console.log(`  3. Validate environment exists in project config`);
}
```

This stub validates both project context AND environment argument. Full implementation comes in Phase 7 (GH-01 through GH-05).
  </action>
  <verify>
Run `npm run build` to verify compilation.
  </verify>
  <done>
src/commands/initialize-github.ts created with:
- runInitializeGitHub(args) exported
- Calls requireProjectContext() to validate project directory
- Validates environment argument (dev, stage, prod)
- Shows appropriate errors for missing or invalid environment
- Shows stub message with project and environment info
  </done>
</task>

<task type="auto">
  <name>Task 4: Update cli.ts to use real command imports</name>
  <files>src/cli.ts</files>
  <action>
Update src/cli.ts to replace the placeholder handlers with real imports:

1. Add imports at top of file:
```typescript
import { runSetupAwsEnvs } from './commands/setup-aws-envs.js';
import { runInitializeGitHub } from './commands/initialize-github.js';
```

2. Update the command routing in run() to use real handlers:
- Replace `setup-aws-envs` placeholder with: `await runSetupAwsEnvs(commandArgs);`
- Replace `initialize-github` placeholder with: `await runInitializeGitHub(commandArgs);`

The setup-github deprecation notice import should already exist from Plan 01.
  </action>
  <verify>
Run `npm run build` to verify compilation.
Verify cli.ts imports all three command modules.
  </verify>
  <done>
cli.ts updated with:
- Import for runSetupAwsEnvs from commands/setup-aws-envs.js
- Import for runInitializeGitHub from commands/initialize-github.js
- Command routing uses real handlers instead of placeholders
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify the full CLI routing with project context detection:

```bash
# Build the project
npm run build

# Test from OUTSIDE a project directory (should fail with helpful error)
cd /tmp
node /path/to/create-aws-starter-kit/dist/index.js setup-aws-envs
# Expected: "Error: Not inside a project directory."

node /path/to/create-aws-starter-kit/dist/index.js initialize-github dev
# Expected: "Error: Not inside a project directory."

# Test missing environment argument
node /path/to/create-aws-starter-kit/dist/index.js initialize-github
# Expected: "Error: Environment name required."

# Test invalid environment argument
node /path/to/create-aws-starter-kit/dist/index.js initialize-github invalid
# Expected: "Error: Invalid environment: invalid"

# Return to project directory
cd /path/to/create-aws-starter-kit
```

Note: Full "inside project" testing requires Phase 5 to generate config file. For now, verify error paths work correctly.
</verification>

<success_criteria>
1. npm run build completes without errors
2. src/utils/project-context.ts exists and exports CONFIG_FILE, detectProjectContext, requireProjectContext
3. src/commands/setup-aws-envs.ts exists and exports runSetupAwsEnvs
4. src/commands/initialize-github.ts exists and exports runInitializeGitHub
5. Running commands from outside project shows "Not inside a project directory" error
6. Running initialize-github without env argument shows usage error
7. Running initialize-github with invalid env shows validation error
8. cli.ts imports all command modules (no placeholders)
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-infrastructure-command-routing/04-02-SUMMARY.md`
</output>
