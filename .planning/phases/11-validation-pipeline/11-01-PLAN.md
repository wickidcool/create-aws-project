---
phase: 11-validation-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/__tests__/harness/run-command.ts
  - src/__tests__/harness/run-command.spec.ts
  - src/__tests__/harness/validate-project.ts
  - src/__tests__/harness/validate-project.spec.ts
autonomous: true

must_haves:
  truths:
    - "Developer can call validateGeneratedProject(config) with any ProjectConfig"
    - "Generated project is scaffolded into temp directory before validation"
    - "Pipeline runs npm ci, npm run build, npm test sequentially (fail-fast)"
    - "Non-zero exit code from any step fails validation with captured output"
    - "Each step has configurable timeout (default 10 minutes)"
    - "Result includes step-by-step tracking with timedOut detection"
  artifacts:
    - path: "src/__tests__/harness/run-command.ts"
      provides: "runCommand with timeout parameter and timedOut return field"
      exports: ["runCommand", "CommandResult"]
      contains: "timeout"
    - path: "src/__tests__/harness/validate-project.ts"
      provides: "Validation pipeline function"
      exports: ["validateGeneratedProject", "ValidationResult", "ValidationStepResult"]
      min_lines: 60
    - path: "src/__tests__/harness/validate-project.spec.ts"
      provides: "Tests for validation pipeline"
      min_lines: 50
  key_links:
    - from: "src/__tests__/harness/validate-project.ts"
      to: "withTempDir"
      via: "import from temp-dir"
      pattern: "import.*withTempDir.*from.*temp-dir"
    - from: "src/__tests__/harness/validate-project.ts"
      to: "runCommand"
      via: "import from run-command"
      pattern: "import.*runCommand.*from.*run-command"
    - from: "src/__tests__/harness/validate-project.ts"
      to: "generateProject"
      via: "import from generator"
      pattern: "import.*generateProject.*from.*generator"
    - from: "src/__tests__/harness/run-command.ts"
      to: "execa timeout"
      via: "timeout option in execa call"
      pattern: "timeout"
---

<objective>
Create the validation pipeline that generates a project into a temp directory and runs npm ci, npm run build, npm test sequentially with timeout support.

Purpose: This is the core validation function that Phase 12-14 will use to test all 14 project configurations.
Output: `validateGeneratedProject(config)` function with structured ValidationResult interface
</objective>

<execution_context>
@/Users/alwick/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alwick/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-validation-pipeline/11-RESEARCH.md
@.planning/phases/10-test-harness-foundation/10-01-SUMMARY.md

# Existing harness utilities from Phase 10
@src/__tests__/harness/temp-dir.ts
@src/__tests__/harness/run-command.ts

# Generator and types needed for validation
@src/generator/generate-project.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timeout support to runCommand</name>
  <files>
    src/__tests__/harness/run-command.ts
    src/__tests__/harness/run-command.spec.ts
  </files>
  <action>
Update runCommand() to accept an optional timeout parameter (default 10 minutes = 600000ms) and return a timedOut field in CommandResult.

1. Update CommandResult interface to add `timedOut?: boolean` field

2. Update runCommand signature:
```typescript
export async function runCommand(
  command: string,
  args: string[],
  cwd: string,
  timeout: number = 600000 // 10 minutes default
): Promise<CommandResult>
```

3. Pass timeout to execa options:
```typescript
const result = await execa(command, args, {
  cwd,
  all: true,
  timeout,
});
```

4. Return timedOut in both success and error paths:
- Success path: `timedOut: false`
- Error path: `timedOut: execaError.timedOut ?? false`

5. Update the error type assertion to include timedOut:
```typescript
const execaError = error as {
  exitCode?: number;
  all?: string;
  message?: string;
  timedOut?: boolean;
};
```

6. Add test to run-command.spec.ts for timeout behavior:
- Test that timeout parameter is passed through (use a very short timeout like 100ms with a command that sleeps)
- Test that timedOut is true when command exceeds timeout
- Use `sleep 1` command with 100ms timeout to verify timeout works
  </action>
  <verify>
Run `npm test -- run-command.spec.ts` - all tests pass including new timeout test
Run `npm run lint` - no TypeScript or lint errors
  </verify>
  <done>
- CommandResult has timedOut field
- runCommand accepts timeout parameter with 10-minute default
- timedOut is true when command exceeds timeout
- timedOut is false on normal success/failure
- Test confirms timeout triggers correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Create validateGeneratedProject function</name>
  <files>
    src/__tests__/harness/validate-project.ts
  </files>
  <action>
Create validate-project.ts with the validation pipeline function.

1. Define interfaces:
```typescript
export interface ValidationStepResult {
  step: 'install' | 'build' | 'test';
  success: boolean;
  exitCode: number;
  output: string;
  timedOut: boolean;
  duration: number;
}

export interface ValidationResult {
  success: boolean;
  failedStep?: 'install' | 'build' | 'test';
  steps: ValidationStepResult[];
  totalDuration: number;
}
```

2. Create validateGeneratedProject function:
```typescript
export async function validateGeneratedProject(
  config: ProjectConfig,
  timeout: number = 600000 // 10 minutes per step
): Promise<ValidationResult>
```

3. Implementation flow:
- Use withTempDir('validate-', async (dir) => { ... }) for isolated execution
- Call generateProject(config, dir, { onProgress: () => {} }) - suppress progress output
- Track steps array to collect all step results
- Run npm ci, then npm run build, then npm test (sequential, fail-fast)
- For each step:
  - Record start time
  - Call runCommand('npm', [...], dir, timeout)
  - Record duration
  - Push to steps array
  - If not success, return early with failedStep set
- Return ValidationResult with success: true if all steps pass

4. Import from local modules:
```typescript
import { withTempDir } from './temp-dir.js';
import { runCommand } from './run-command.js';
import { generateProject } from '../../generator/generate-project.js';
import type { ProjectConfig } from '../../types.js';
```

Note: Use npm ci (not npm install) for deterministic installs per research recommendations.
  </action>
  <verify>
Run `npm run lint` - no TypeScript errors
Run `npm run build` - build succeeds
  </verify>
  <done>
- ValidationResult and ValidationStepResult interfaces exported
- validateGeneratedProject function exported
- Function uses withTempDir for isolation
- Function calls generateProject to scaffold
- Function runs npm ci -> npm run build -> npm test sequentially
- Fail-fast behavior: stops at first failure
- Each step records duration, exitCode, output, timedOut
- Timeout parameter defaults to 10 minutes (600000ms)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add validation pipeline tests</name>
  <files>
    src/__tests__/harness/validate-project.spec.ts
  </files>
  <action>
Create validate-project.spec.ts with tests for the validation pipeline.

IMPORTANT: These are unit tests that mock the dependencies (withTempDir, generateProject, runCommand).
Real integration tests (generating actual projects) will be in Phase 12+ as they take 30+ minutes.

1. Mock all dependencies:
```typescript
import { describe, test, expect, vi, beforeEach } from 'vitest';
import { validateGeneratedProject } from './validate-project.js';
import type { ProjectConfig } from '../../types.js';

// Mock the dependencies
vi.mock('./temp-dir.js', () => ({
  withTempDir: vi.fn(),
}));
vi.mock('./run-command.js', () => ({
  runCommand: vi.fn(),
}));
vi.mock('../../generator/generate-project.js', () => ({
  generateProject: vi.fn(),
}));
```

2. Create test helper for minimal config:
```typescript
function createTestConfig(): ProjectConfig {
  return {
    projectName: 'test-project',
    platforms: ['web'],
    awsRegion: 'us-east-1',
    features: [],
    brandColor: 'blue',
    auth: { provider: 'none', features: [] },
  };
}
```

3. Test cases:

a) "returns success when all steps pass"
- Mock withTempDir to call the callback with a fake directory
- Mock generateProject to resolve
- Mock runCommand to return success for all 3 calls
- Verify result.success is true
- Verify steps has 3 entries (install, build, test)
- Verify no failedStep

b) "returns failure when npm ci fails"
- Mock runCommand to return failure on first call
- Verify result.success is false
- Verify result.failedStep is 'install'
- Verify steps has only 1 entry (stopped at install)

c) "returns failure when npm run build fails"
- Mock runCommand to succeed first, fail second
- Verify result.failedStep is 'build'
- Verify steps has 2 entries

d) "returns failure when npm test fails"
- Mock runCommand to succeed first two, fail third
- Verify result.failedStep is 'test'
- Verify steps has 3 entries

e) "tracks timedOut in step results"
- Mock runCommand to return timedOut: true
- Verify step result has timedOut: true

f) "passes timeout to runCommand"
- Call validateGeneratedProject with custom timeout (e.g., 300000)
- Verify runCommand was called with that timeout value

g) "calls generateProject with config and directory"
- Verify generateProject was called with the config and the temp dir

4. Use beforeEach to reset mocks between tests.
  </action>
  <verify>
Run `npm test -- validate-project.spec.ts` - all tests pass
Run `npm run lint` - no lint errors
  </verify>
  <done>
- Test file exists at src/__tests__/harness/validate-project.spec.ts
- Tests use mocks (no real project generation)
- Tests cover success path, failure at each step, timeout tracking
- Tests verify correct parameters passed to dependencies
- All tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run full test suite: `npm test` - all tests pass
2. Run lint: `npm run lint` - no errors
3. Run build: `npm run build` - succeeds

Verify exports work:
```typescript
// This should compile without errors
import { validateGeneratedProject, ValidationResult } from './validate-project.js';
import { runCommand, CommandResult } from './run-command.js';
```
</verification>

<success_criteria>
Phase 11 requirements satisfied:

- [x] HARN-01: validateGeneratedProject accepts any ProjectConfig
- [x] HARN-03: Pipeline runs npm ci, npm run build, npm test sequentially
- [x] HARN-04: Non-zero exit codes result in failure with captured output
- [x] REPT-03: Each step has configurable timeout (default 10 minutes)

Additionally:
- ValidationResult provides step-by-step tracking
- timedOut detection for debugging hanging processes
- Fail-fast behavior saves time on early failures
- Unit tests validate pipeline logic without slow integration tests
</success_criteria>

<output>
After completion, create `.planning/phases/11-validation-pipeline/11-01-SUMMARY.md`
</output>
